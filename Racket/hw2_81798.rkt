#lang racket

; ===================================================================
; Задача 1. Да се дефинира функция (special-digit x), която връща
; специалната цифра, отговаряща на числото x. Ако числото x е едноцифрено, то
; неговата специална цифра съвпада с него. В противен случай специалната цифра
; на числото x съвпада със специалната цифра на сумата от цифрите на x.

(define (special-digit x)
  (define (sum-digits res num)
    (cond [(= num 0) res]
          [else (sum-digits (+ res (modulo num 10)) (quotient num 10))]))
  (cond [(< x 10) x]
        [else (special-digit (sum-digits 0 x))]))

; Пример:
; (special-digit 2); → 2
; (special-digit 1234); → 1

; ===================================================================
; Задача 2. Да се дефинира функция (find-max f a b), която по дадена
; двуаргументна числова функция f и цели числа a и b намира най-голямата
; стойност от вида: f(i, f(i+1, ... f(j-1, j))) за a ≤ i < j ≤ b.


(define (find-max f a b)
  (define (iter max i j)
    (define (get-val res k)
      (cond [(< k i) res]
            [else (get-val (f k res) (- k 1))]))
    (cond [(> i b) max]
          [(> j b) (iter max (+ 1 i) (+ 2 i))]
          [(> (get-val j (- j 1)) max) (iter (get-val j (- j 1)) i (+ 1 j))]
          [else (iter max i (+ 1 j))]))
  (iter 0 a (+ a 1)))

; Пример:
;(find-max - 1 5); → 4 (= 3 - (4 - 5))

; ===================================================================
; Задача 3. Да се дефинира функция (filtered-sum p? f), която приема
; предикат p? и едноаргументна функция f и връща едноаргументна функция.
; Върнатата от filtered-sum функция трябва да приема като аргумент списък от
; цели положителни числа xs. Нека S е сумата на всички числа от xs – такива, че
; стойността на предиката p? за квадрата на индекса им в xs е истина. Върнатата
; функция трябва да върне резултата от прилагането на f към сумата S.
; Счита се, че индексирането на списъка xs започва от 0.

(define (filtered-sum p? f)
  (λ (xs)
    (define (iter res index x)
      (cond [(null? x) res]
            [(p? (expt index 2)) (iter (+ res (car x)) (+ 1 index) (cdr x))]
            [else (iter res (+ 1 index) (cdr x))]))
    (f (iter 0 0 xs))))

; Пример:
;((filtered-sum (λ (z) (= 0 (remainder z 3))) (λ (s) (* s 2))) `(1 2 3 4)); → 10
